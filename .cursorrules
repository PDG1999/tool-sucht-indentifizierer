# üåç UNIVERSAL CURSOR RULES
# Version: 1.0 | Works with ALL programming languages automatically
# Repository: https://github.com/PDG1999/pdg-cursorrules
# 
# This file automatically adapts to ANY programming language/framework
# Just copy to your project root as '.cursorrules' and Cursor does the rest!

## üß† UNIVERSAL AI BEHAVIOR (works for ANY language)
- **NO Apologies**: Fix errors immediately with explanation, don't apologize  
- **Complete Solutions**: Show FULL file content, never truncated snippets
- **Test-Driven Development**: Write tests first, then implement code to pass tests
- **Security First**: Consider security implications in every code suggestion
- **Performance Aware**: Always consider performance impact of changes
- **Explain WHY**: Always explain reasoning behind architectural decisions
- **Error Handling**: Include comprehensive error handling in all suggestions
- **Documentation**: Provide clear comments and documentation for complex logic

## üèóÔ∏è UNIVERSAL QUALITY STANDARDS (apply to ALL programming languages)

### üõ°Ô∏è SECURITY BY DEFAULT
```
ALWAYS enforce these security principles:
- NEVER trust user input - validate and sanitize everything
- Use parameterized queries for database operations (prevent SQL injection)
- Hash passwords using proper algorithms (bcrypt, Argon2)
- Implement proper authentication and authorization
- Use HTTPS for all external communications
- Never hardcode secrets, API keys, or passwords in source code
- Implement proper session management
- Log security events for monitoring
```

### ‚ö° PERFORMANCE CONSCIOUSNESS  
```
Optimize for performance by default:
- Avoid N+1 query problems in database operations
- Use appropriate data structures for the task
- Implement caching strategies where beneficial
- Minimize network requests and payload sizes
- Use lazy loading for large datasets
- Profile and measure performance improvements
- Consider memory usage and garbage collection
```

### üîß ERROR HANDLING EXCELLENCE
```
Every function that can fail MUST:
- Handle errors gracefully with try/catch or equivalent
- Provide meaningful error messages for users
- Log detailed error information for developers
- Implement proper fallback mechanisms
- Fail fast when recovery is impossible
- Use proper exception types/error codes
```

### üìÅ CODE ORGANIZATION PRINCIPLES
```
Maintain clean architecture:
- Single Responsibility Principle (one function, one purpose)
- DRY - Don't Repeat Yourself
- Clear and descriptive naming conventions
- Consistent file and folder structure
- Separate concerns (business logic, UI, data access)
- Keep functions under 50 lines when possible
- Use appropriate design patterns
```

### üß™ TESTING DISCIPLINE
```
Implement comprehensive testing:
- Unit tests for business logic functions
- Integration tests for API endpoints and database operations
- End-to-end tests for critical user workflows
- Test edge cases and error conditions
- Maintain minimum 80% test coverage
- Write tests BEFORE implementing features (TDD)
- Use proper mocking and test data
```

## üö´ UNIVERSAL ANTI-PATTERNS (forbidden in ANY language)

### ‚ùå NEVER DO THESE (regardless of programming language):
- Hardcode secrets, passwords, API keys, or configuration in source code
- Ignore error conditions or fail silently without logging
- Use global variables for application state management
- Write functions longer than 50 lines without compelling reason
- Leave debug statements (console.log, print, var_dump) in production code
- Skip input validation on user-provided data
- Use deprecated or known-vulnerable libraries
- Write code without any comments or documentation
- Ignore linting warnings without documented reasons
- Mix business logic directly with presentation logic
- Use magic numbers or strings without named constants
- Implement custom crypto instead of using proven libraries

## üéØ ADAPTIVE BEHAVIOR PATTERNS

### üîç AUTO-DETECTION & ADAPTATION
```
Cursor will automatically detect and adapt to:

FRONTEND FRAMEWORKS:
- React: Use functional components, hooks, TypeScript interfaces
- Vue: Use Composition API, TypeScript, single-file components  
- Angular: Use services, dependency injection, RxJS patterns
- Svelte: Use reactive statements and proper component lifecycle

BACKEND TECHNOLOGIES:
- Node.js: Use Express patterns, middleware, async/await
- Python: Use type hints, proper exception handling, PEP 8
- PHP: Use PSR standards, prepared statements, input sanitization
- C#: Use async/await, dependency injection, Entity Framework patterns
- Go: Use proper error handling, goroutines, standard library patterns
- Rust: Use Result<T,E>, proper ownership, memory safety patterns

CMS & FRAMEWORKS:
- WordPress: Use WordPress Coding Standards, hooks, sanitization functions
- Laravel: Use Eloquent ORM, Artisan commands, proper MVC structure
- Django: Use Django ORM, class-based views, proper URL routing
```

### üé® LANGUAGE-SPECIFIC ADAPTATIONS

#### When JavaScript/TypeScript is detected:
```typescript
// ‚úÖ EXCELLENT PATTERNS:
interface ComponentProps {
  data: DataType;
  onAction?: (item: DataType) => void;
  className?: string;
}

export const Component: React.FC<ComponentProps> = ({ 
  data, 
  onAction,
  className = ""
}) => {
  const [loading, setLoading] = useState(false);
  
  useEffect(() => {
    // Effect logic with proper cleanup
    const cleanup = () => {
      // Cleanup subscriptions, timers, etc.
    };
    
    return cleanup;
  }, []);
  
  return <div className={className}>{/* Implementation */}</div>;
};

// FORBIDDEN in JavaScript/TypeScript:
// ‚ùå var (use const/let)
// ‚ùå class components in React
// ‚ùå Missing key in .map()
// ‚ùå Inline styles (use CSS modules/Tailwind)
// ‚ùå useEffect without cleanup function
// ‚ùå Uncontrolled form inputs without proper state
```

#### When Python is detected:
```python
# ‚úÖ EXCELLENT PATTERNS:
from typing import List, Optional, Dict, Any
import logging

logger = logging.getLogger(__name__)

def process_data(
    data: List[Dict[str, Any]], 
    validate: bool = True
) -> Optional[ProcessedResult]:
    """Process data with proper error handling and type hints.
    
    Args:
        data: Input data to process
        validate: Whether to perform input validation
        
    Returns:
        Processed result or None if processing fails
        
    Raises:
        ValueError: If input validation fails
        ProcessingError: If data processing encounters an error
    """
    try:
        if validate:
            _validate_input(data)
            
        result = _perform_processing(data)
        logger.info(f"Successfully processed {len(data)} items")
        return result
        
    except Exception as e:
        logger.error(f"Data processing failed: {e}")
        raise

# FORBIDDEN in Python:
# ‚ùå Bare except clauses
# ‚ùå Global variables for state
# ‚ùå Missing type hints
# ‚ùå Hardcoded file paths
# ‚ùå print() statements (use logging)
```

#### When WordPress/PHP is detected:
```php
<?php
// ‚úÖ EXCELLENT PATTERNS:
function handle_user_submission() {
    // Verify nonce for security
    if (!wp_verify_nonce($_POST['nonce'], 'user_action')) {
        wp_die('Security check failed');
    }
    
    // Sanitize all inputs
    $user_input = sanitize_text_field($_POST['user_data']);
    $email = sanitize_email($_POST['email']);
    
    // Validate inputs
    if (empty($user_input) || !is_email($email)) {
        return new WP_Error('invalid_input', 'Please provide valid data');
    }
    
    // Use prepared statements for database operations
    global $wpdb;
    $result = $wpdb->insert(
        $wpdb->prefix . 'custom_table',
        array(
            'user_data' => $user_input,
            'email' => $email,
            'created_at' => current_time('mysql')
        ),
        array('%s', '%s', '%s')
    );
    
    if ($result === false) {
        error_log('Database insert failed: ' . $wpdb->last_error);
        return new WP_Error('db_error', 'Failed to save data');
    }
    
    return true;
}

// FORBIDDEN in WordPress/PHP:
// ‚ùå Direct $_POST/$_GET usage without sanitization
// ‚ùå SQL queries without $wpdb->prepare()
// ‚ùå Missing nonce verification
// ‚ùå Hardcoded WordPress paths
// ‚ùå var_dump() in production code
?>
```

#### When C#/.NET is detected:
```csharp
// ‚úÖ EXCELLENT PATTERNS:
public async Task<ActionResult<User>> GetUserAsync(
    int id, 
    CancellationToken cancellationToken = default)
{
    try
    {
        if (id <= 0)
        {
            return BadRequest("Invalid user ID");
        }

        var user = await _context.Users
            .Where(u => u.Id == id)
            .FirstOrDefaultAsync(cancellationToken);

        if (user == null)
        {
            return NotFound($"User with ID {id} not found");
        }

        return Ok(user);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Failed to retrieve user {UserId}", id);
        return StatusCode(500, "Internal server error");
    }
}

// FORBIDDEN in C#:
// ‚ùå Blocking async calls (.Result, .Wait())
// ‚ùå Missing CancellationToken in async methods
// ‚ùå Raw SQL without parameterization
// ‚ùå Missing exception handling
```

#### When Go is detected:
```go
// ‚úÖ EXCELLENT PATTERNS:
func ProcessUserData(ctx context.Context, data []UserData) (*ProcessedResult, error) {
    if len(data) == 0 {
        return nil, fmt.Errorf("no data provided")
    }

    // Validate input data
    for i, item := range data {
        if err := validateUserData(item); err != nil {
            return nil, fmt.Errorf("invalid data at index %d: %w", i, err)
        }
    }

    // Process with context cancellation support
    select {
    case <-ctx.Done():
        return nil, ctx.Err()
    default:
        result, err := performProcessing(data)
        if err != nil {
            return nil, fmt.Errorf("processing failed: %w", err)
        }
        return result, nil
    }
}

// FORBIDDEN in Go:
// ‚ùå Ignoring errors (_, err := func(); if err != nil...)
// ‚ùå Not using context.Context for cancellation
// ‚ùå panic() in library code
// ‚ùå Not handling goroutine lifecycle properly
```

#### When Python Data Science/ML is detected:
```python
# ‚úÖ DATA SCIENCE PATTERNS:
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
import logging

# Set reproducible seeds
np.random.seed(42)

def prepare_dataset(df: pd.DataFrame, target_column: str) -> tuple:
    """Prepare dataset with proper validation and reproducible splits.
    
    Args:
        df: Input dataframe
        target_column: Name of target column
        
    Returns:
        Tuple of (X_train, X_test, y_train, y_test)
        
    Raises:
        ValueError: If target column missing or data invalid
    """
    # Data validation
    if target_column not in df.columns:
        raise ValueError(f"Target column '{target_column}' not found")
    
    if df.isnull().sum().sum() > 0:
        logging.warning("Missing values detected, handling with forward fill")
        df = df.fillna(method='ffill')
    
    # Optimize memory usage
    for col in df.select_dtypes(include=['object']).columns:
        if col != target_column:
            df[col] = df[col].astype('category')
    
    # Prepare features and target
    X = df.drop(columns=[target_column])
    y = df[target_column]
    
    # Reproducible split
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=42, stratify=y
    )
    
    logging.info(f"Dataset prepared: {X_train.shape[0]} training samples")
    return X_train, X_test, y_train, y_test

# FORBIDDEN in Data Science:
# ‚ùå Not setting random seeds
# ‚ùå No data validation
# ‚ùå Memory-inefficient pandas operations
# ‚ùå Missing experiment documentation
```

## ‚úÖ UNIVERSAL VERIFICATION CHECKLIST

### Before completing ANY coding task, verify:
‚úÖ **Security**: Input validation implemented? No hardcoded secrets?
‚úÖ **Error Handling**: Comprehensive try/catch with meaningful messages?
‚úÖ **Performance**: No obvious bottlenecks or inefficient algorithms?
‚úÖ **Testing**: Code is testable? Test cases included where appropriate?
‚úÖ **Documentation**: Complex logic documented with clear comments?
‚úÖ **Standards**: Code follows language/framework conventions?
‚úÖ **Maintainability**: Future developers can easily understand this code?
‚úÖ **Type Safety**: Proper types/interfaces defined (for typed languages)?

## üéØ SMART WORKFLOW COMMANDS

### Universal Commands (work with any language/framework):
```
DEBUGGING: 
"Debug @file [FILENAME] systematically - reproduce issue, isolate cause, implement fix, verify solution"

CODE QUALITY: 
"Review @file [FILENAME] for security vulnerabilities, performance issues, and adherence to best practices"  

TESTING: 
"Add comprehensive tests to @file [FILENAME] covering normal cases, edge cases, and error conditions"

DOCUMENTATION: 
"Add proper documentation to @file [FILENAME] following language/framework documentation standards"

ARCHITECTURE: 
"Review architecture of @folder [FOLDERNAME] and suggest improvements following established patterns"

SECURITY AUDIT: 
"Perform security audit of @file [FILENAME] checking for common vulnerabilities and security best practices"

PERFORMANCE: 
"Analyze and optimize @file [FILENAME] for performance, focusing on bottlenecks and efficiency improvements"

REFACTORING:
"Refactor @file [FILENAME] to improve maintainability while preserving functionality"

CODE REVIEW:
"Review this code following our established patterns and suggest improvements"
```

## üîÑ CONTINUOUS ADAPTATION & LEARNING

### Rule Evolution Process:
```
WHEN bugs occur frequently:
‚Üí Add specific prevention rules to avoid similar issues

WHEN new patterns emerge:
‚Üí Update rules to reflect current best practices

WHEN team feedback indicates issues:
‚Üí Incorporate team preferences and standards

WHEN performance problems arise:
‚Üí Add performance-focused rules and monitoring

WHEN security issues are discovered:
‚Üí Strengthen security rules and validation requirements
```

### Context Building:
```
For each project, automatically consider:
1. Primary language and version from files/dependencies
2. Framework and its current version
3. Project architecture (MVC, microservices, monolith, etc.)
4. Database technology and ORM in use
5. Testing framework and coverage expectations
6. Deployment target and environment considerations
7. Team size and collaboration patterns
```

## üí° ADVANCED FEATURES

### Multi-Language Project Support:
```
For projects using multiple languages:
- Apply appropriate rules based on file extension context
- Maintain consistency in cross-language interactions (APIs, data formats)
- Use proper serialization/deserialization between language boundaries
- Implement consistent error handling across language barriers
```

### Framework Integration Intelligence:
```
Automatically recognize and optimize for:
- Build tools (Webpack, Vite, Rollup, Parcel, etc.)
- Package managers (npm, yarn, pip, composer, cargo, etc.)
- CI/CD pipelines (GitHub Actions, Jenkins, GitLab CI, etc.)
- Cloud platforms (AWS, Azure, GCP, Vercel, Netlify)
- Database migrations and schema management
- API documentation tools (Swagger/OpenAPI, Postman, etc.)
```

## üöÄ PROJECT-SPECIFIC CUSTOMIZATION

### Add these sections at the end for project-specific needs:

```
## üéØ PROJECT-SPECIFIC RULES
# Uncomment and customize as needed:
# - Use our internal API naming conventions
# - Follow company-specific error code standards  
# - Include project-specific logging requirements
# - Implement custom authentication patterns

## üë• TEAM COLLABORATION RULES  
# Uncomment and customize as needed:
# - Use Conventional Commits (feat:, fix:, docs:, etc.)
# - Include PR template requirements
# - Follow code review checklist standards
# - Maintain API documentation standards

## üè¢ INDUSTRY-SPECIFIC ADAPTATIONS
# Uncomment and customize as needed:
# FINTECH: Extra security measures, audit logging, compliance requirements
# HEALTHCARE: HIPAA compliance, data encryption, access logging
# E-COMMERCE: PCI compliance, inventory management, transaction safety
# EDUCATION: FERPA compliance, accessibility standards, data protection
```

---

## üìö USAGE EXAMPLES

### For a new React component:
**Prompt**: "Create a user profile component with form validation"
**Expected**: TypeScript interfaces, functional component with hooks, proper error handling, accessibility features

### For a Python API endpoint:
**Prompt**: "Create an API endpoint to handle user registration"  
**Expected**: Type hints, input validation, proper HTTP status codes, error logging, security considerations

### For WordPress functionality:
**Prompt**: "Create a custom post type with meta fields"
**Expected**: WordPress coding standards, proper sanitization, hooks usage, security nonces

### For database operations:
**Prompt**: "Create a function to update user preferences"
**Expected**: Parameterized queries, transaction handling, error recovery, proper logging

---

---

## üéØ SAMEBI MULTI-TOOL PLATFORM - SPEZIFISCHE REGELN

### üèóÔ∏è TEMPLATE-FIRST ARCHITEKTUR
```
KRITISCHE TEMPLATE-REGELN:
- JEDES neue Tool MUSS vom Master-Template abgeleitet sein
- KEINE Duplikation von Code zwischen Tools
- Content kommt IMMER aus shared-cms/, nie hardcoded
- Multi-Language Support (DE/EN/ES) ist PFLICHT f√ºr jedes Tool
- White-Label ready: Logo, Farben, Branding dynamisch
- Lead-Capture standardisiert √ºber alle Tools
```

### üìä MULTI-TOOL MANAGEMENT
```
TOOL-ORGANISATION:
- Naming-Convention: tool-[name]/ (kleingeschrieben, Bindestriche)
- Jedes Tool = eigenes Git-Directory
- Shared Components in shared-components/
- Shared Content in shared-cms/
- Subdomain-Struktur: [tool-name].samebi.net
- Sprach-Varianten: [tool-name]-de/es/en oder separate Subdomains
```

### üåê SUBDOMAIN & DEPLOYMENT STRATEGIE
```
DEPLOYMENT-REGELN:
- 1 Tool = 3 Sprach-Versionen (DE/ES/EN)
- Separate Subdomains pro Sprache f√ºr SEO
- Beispiel: stress-test.samebi.net (DE)
           test-estres.samebi.net (ES)
           stress-check.samebi.net (EN)
- Coolify Auto-Deployment via Git Push
- SSL automatisch (Let's Encrypt)
- Monitoring mit Uptime Robot
```

### üîÑ AUTOMATION-FIRST
```
N8N WORKFLOW-REGELN:
- Deployment MUSS automatisiert sein
- Lead-Processing automatisch zu CRM
- Content-Updates deployen automatisch
- Monitoring-Alerts automatisch
- Backup t√§glich automatisch
- Analytics-Reports w√∂chentlich automatisch
```

### üíæ DATABASE & BACKEND
```
BACKEND-ARCHITEKTUR:
- PostgreSQL als Single Source of Truth
- Redis f√ºr Caching & Session Management
- PostgREST f√ºr automatische REST API
- KEINE Tool-spezifische Datenbank-Logik
- Shared Backend: herramientas-backend/
- API Endpoint-Struktur: api.samebi.net/tools/[tool-name]/
```

### üé® UI/UX KONSISTENZ
```
FRONTEND-REGELN:
- React + TypeScript + Vite (Standard-Stack)
- Tailwind CSS f√ºr alle Styles
- KEINE Inline-Styles
- Responsive Design (Mobile-First)
- Accessibility (WCAG 2.1)
- Loading-States f√ºr alle async Operations
- Error-Boundaries f√ºr robuste UX
```

### üìß LEAD-CAPTURE SYSTEM
```
LEAD-PROCESSING:
- Jedes Tool MUSS Lead-Capture haben
- Email-Validation client- UND server-side
- Lead-Scoring basierend auf Tool & Completion
- Automatische Email-Sequenz √ºber Brevo
- CRM-Integration (Airtable oder PostgreSQL)
- Analytics-Tracking (Google Analytics)
- DSGVO-konform: Opt-in required
```

### üåç MULTI-LANGUAGE SUPPORT
```
I18N-REGELN:
- Translations in src/i18n/[de|en|es].json
- NIEMALS hardcoded Texte im Code
- Language-Detection via Environment Variable
- SEO-Meta-Tags sprachspezifisch
- Hreflang-Tags f√ºr alternate Sprachen
- Date/Number-Formatting lokalisiert
```

### üí∞ MONETARISIERUNG & TRACKING
```
BUSINESS-LOGIC:
- Track Source-Tool f√ºr jeden Lead
- Conversion-Funnel Tracking
- Payment-Integration via Stripe
- Kurs-Zugang √ºber course_access Tabelle
- White-Label Client Management
- Revenue-Attribution pro Tool/Sprache
```

### üîê SECURITY & COMPLIANCE
```
SICHERHEITS-REGELN:
- DSGVO-konform: Server in EU (Hetzner)
- SSL/TLS f√ºr alle Verbindungen
- Input-Validierung √ºberall
- SQL-Injection Prevention (Parameterized Queries)
- XSS-Protection (Content Security Policy)
- Rate-Limiting auf API-Ebene
- Secrets nur in Environment Variables
```

### üìä MONITORING & ANALYTICS
```
√úBERWACHUNG:
- Uptime-Monitoring f√ºr ALLE Tools
- Performance-Metriken (Core Web Vitals)
- Error-Tracking (Console-Errors loggen)
- Conversion-Tracking pro Tool
- A/B-Testing Support
- Dashboard: dashboard.samebi.net zeigt √úbersicht
```

## üöÄ SAMEBI-SPEZIFISCHE WORKFLOW-COMMANDS

### Tool Development:
```
"Erstelle neues Assessment-Tool basierend auf Master-Template mit Multi-Language Support und Lead-Capture"
"Optimiere Tool-Performance f√ºr Core Web Vitals Score >90"
"Implementiere A/B-Testing f√ºr Landing-Page Varianten"
```

### Template System:
```
"Erweitere Master-Template um neue Component-Type [Quiz|Calculator|Assessment]"
"Generiere Tool-Config f√ºr [Tool-Name] mit Fragen-Set"
"Deploy neues Tool in 3 Sprachen mit automatischer DNS-Konfiguration"
```

### Backend & API:
```
"Erstelle neuen API-Endpoint f√ºr Tool-Analytics"
"Optimiere PostgreSQL Queries mit Indexing"
"Implementiere Redis-Caching f√ºr h√§ufige Abfragen"
```

### Automation:
```
"Erstelle N8N Workflow f√ºr automatisches Tool-Deployment"
"Implementiere automatische Content-Updates aus CMS"
"Setup automatische Backup-Strategie f√ºr PostgreSQL"
```

## üìã SAMEBI-SPEZIFISCHE CHECKLISTE

### Vor jedem Tool-Launch:
‚úÖ **Multi-Language**: Alle 3 Sprachen (DE/EN/ES) funktionieren  
‚úÖ **Lead-Capture**: Email-Validation & CRM-Integration aktiv  
‚úÖ **SEO**: Meta-Tags, Open Graph, Structured Data  
‚úÖ **Performance**: Lighthouse Score >90  
‚úÖ **Mobile**: Touch-optimiert, responsive  
‚úÖ **Analytics**: Google Analytics tracking funktioniert  
‚úÖ **Monitoring**: Uptime Robot konfiguriert  
‚úÖ **SSL**: HTTPS funktioniert  

### Vor jedem Deployment:
‚úÖ **Template-Konform**: Kein duplizierter Code  
‚úÖ **CMS-Integration**: Content kommt von shared-cms  
‚úÖ **API-Kompatibel**: Backend-Endpoints funktionieren  
‚úÖ **Error-Handling**: Alle async Calls mit try/catch  
‚úÖ **Environment Variables**: Keine Secrets im Code  
‚úÖ **Git-Clean**: Keine build-artifacts committed  
‚úÖ **Tests**: Kritische Flows getestet  
‚úÖ **Documentation**: README.md aktualisiert  

### Vor jedem Release:
‚úÖ **Backup**: PostgreSQL Backup erfolgreich  
‚úÖ **Load-Testing**: Performance unter Last getestet  
‚úÖ **Cross-Browser**: Chrome, Firefox, Safari, Edge  
‚úÖ **Mobile-Testing**: iOS & Android  
‚úÖ **Security-Scan**: Keine bekannten Vulnerabilities  
‚úÖ **Analytics**: Dashboard zeigt korrekte Daten  
‚úÖ **Rollback-Plan**: Schnelles Rollback m√∂glich  
‚úÖ **Stakeholder-Approval**: Team hat approved  

---

## üéØ SAMEBI BUSINESS-ZIELE ALIGNMENT

### Exit-Readiness (5-15M‚Ç¨ Ziel):
```
CODE-QUALIT√ÑT f√ºr Acquisition:
- Clean Architecture (nachvollziehbar f√ºr K√§ufer)
- Standard Tech-Stack (React, PostgreSQL, keine Exotic-Tech)
- Vollst√§ndige Dokumentation
- Hohe Test-Coverage (>80%)
- Skalierbare Infrastructure (bewiesene Skalierung)
- Kein Vendor-Lock-in (self-hosted, open-source wo m√∂glich)
```

### Platform-Skalierung (150+ Apps Ziel):
```
SKALIERUNGS-PRINZIPIEN:
- Template-System f√ºr schnelle Tool-Erstellung
- Automation f√ºr repetitive Tasks
- Monitoring f√ºr fr√ºhzeitige Problem-Erkennung
- Caching f√ºr Performance unter Last
- Horizontal-Scaling m√∂glich (mehr Server bei Bedarf)
- Content-Delivery optimiert (CDN-ready)
```

---

## üñ•Ô∏è SAMEBI INFRASTRUCTURE & SERVER-ZUGANG

### Server-Zugriff:
```
WICHTIG: Alle Infrastructure-Details sind dokumentiert in INFRASTRUCTURE.md

Server-Zugang:
- Hetzner Server IP: 91.98.93.203
- SSH-Key: ~/.ssh/id_ed25519_hetzner
- SSH-Config bereits eingerichtet
- Deployment via Coolify (Self-Hosted)

Bei Server-Operationen:
1. IMMER INFRASTRUCTURE.md konsultieren
2. SSH-Key verwenden (nie Passwort)
3. Vor kritischen √Ñnderungen Backup pr√ºfen
4. Rollback-Plan bereithalten
5. Monitoring-Alerts beachten

Siehe INFRASTRUCTURE.md f√ºr:
- Vollst√§ndige Server-Details
- PostgreSQL-Connection-Strings
- Docker-Container-Namen
- Port-Mappings
- Domain-Konfiguration
- Coolify-Zugang
```

---

## üîê SAMEBI AUTH SERVICE

### Architecture Decision:
```
KRITISCHE ARCHITEKTUR-ENTSCHEIDUNG (Oktober 2025):

Auth via DEDIZIERTER MICROSERVICE statt PostgreSQL Functions!

Warum:
- ‚úÖ 4-10x schneller (50ms vs 200-500ms)
- ‚úÖ 100% JWT-Standard-konform (keine HMAC-Bugs)
- ‚úÖ Horizontal skalierbar (Millionen User m√∂glich)
- ‚úÖ Exit-ready: +20-40% Bewertung
- ‚úÖ Erweiterbar: OAuth, 2FA in Stunden statt Wochen
- ‚úÖ Wartbar: Standard Node.js, kein SQL-Magic

Location: /auth-service/
Docs: AUTH-SERVICE-SETUP.md
```

### Auth-Service Regeln:
```
IMMER BEACHTEN:
- JWT Secret MUSS mit PGRST_JWT_SECRET √ºbereinstimmen
- Passwords IMMER mit bcrypt (cost 12)
- Rate Limiting ist PFLICHT (5 attempts / 15min)
- Structured Logging (Winston) - KEINE Secrets loggen
- Health Checks f√ºr Kubernetes-Readiness
- Graceful Shutdown implementiert
- CORS nur f√ºr whitelisted Origins
- Docker Container als non-root User

BEI AUTH-√ÑNDERUNGEN:
1. Integration-Tests laufen lassen
2. Token-Format mit PostgREST verifizieren
3. Dashboard-Integration testen
4. Monitoring-Alerts pr√ºfen
5. Documentation aktualisieren
```

### Auth API Endpoints:
```
POST /auth/login
POST /auth/verify
POST /auth/register (vorbereitet)
GET /health

BASE URL: https://auth.samebi.net
LOCAL: http://localhost:3001

NIEMALS:
- Passwords im Klartext loggen
- JWT Secrets hardcoden
- Rate Limiting deaktivieren
- CORS f√ºr alle Origins √∂ffnen (*)
```

### Dashboard Integration:
```
// ALT (PostgREST - DEPRECATED):
const response = await apiCall('/rpc/login', { ... });

// NEU (Auth Service - PRODUCTION):
const response = await fetch('https://auth.samebi.net/auth/login', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ email, password })
});

Migration Status:
- ‚úÖ Auth Service deployed
- üîÑ Dashboard migration in progress
- ‚è≥ PostgREST login() deprecation pending
```

---

**üéØ Diese SAMEBI-spezifischen Regeln erg√§nzen die universellen Cursor-Regeln und stellen sicher, dass alle Entwicklungen aligned sind mit der Multi-Tool Platform Vision, der Template-First Architektur und dem 5-15M‚Ç¨ Exit-Ziel.**

---

**üåü This universal rules system adapts intelligently to your specific technology stack while maintaining consistent quality standards across all programming languages and frameworks.**

**üí° Diese .cursorrules macht Cursor zum perfekten Co-Piloten f√ºr Ihr SAMEBI-Projekt - jede Code-Suggestion wird automatisch auf diese Standards gepr√ºft!**

**üöÄ Mit diesen Regeln k√∂nnen Sie 150+ Tools entwickeln, die perfekt aufeinander abgestimmt sind und h√∂chste Qualit√§tsstandards erf√ºllen!**